//Documentazione

La scelta implementativa sia per quanto riguarda le strutture di dati sia per le funzioni relative a pcb e semafori segue pressoche' la descrizione del file
di istruzioni in allegato alla fase1 relativa al progetto del corso di sistemi operativi.

//PCBs

//PCBs queues


La lista pcbFree e`una lista circolare bidirezioanle con sentinella (pcbFree_h) e il campo struct list_head p_next della struct pcb_t e`
usato come concatenatore dei vari pcb_t fra di loro e con la sentinella, anch'essa di tipo struct list_head

La circolarita' della lista semplifica aspetti come l'inserimento o la rimozione in testa e/o in coda di elementi nella/dalla lista

L'uso della sentinella e` stato mantenuto per la leggibilita´ del codice

//PCBs trees


I PCB posso essere organizzati ad albero.
Ogni PCB genitore attraverso il proprio campo p_child.next punta esclusivamente al campo p_child del primo figlio e nel caso ne abbia piu d'uno,
il primo figlio sara'il primo elemento di una lista di PCB fratelli concatenata attraverso il campo struct list_head p_sib bidirezionale non circolare,
senza sentinella

Partendo da un PCB si puo` quindi anche pensare di scorrere una "lista dei primogeniti" e siccome l'inserimento di un PCB fra i figli di un altro
avviene in coda, il ruolo del primogenito e´ quello del piu` vecchio PCB inserito fra i figli del padre, questa lista risulta essere
anch'essa bidirezionale non circolare, senza sentinella

Ogni PCB punta al proprio padre con un campo specifico per questo scopo struct pcb_t* p_parent


//Semafori


La lista semdFree dei semafori liberi e`una lista circolare bidirezioanle con sentinella e il campo struct list_head s_next della struct semd_t e`
usato come concatenatore dei vari semd_t fra di loro e con la sentinella, anch'essa di tipo struct list_head


//ASL

La lista dei semafori attivi ASL e`una lista circolare bidirezioanle con sentinella (semdFree_h) e il campo struct list_head s_next della struct semd_t e`
usato come concatenatore dei vari semd_t fra di loro e con la sentinella

I processi bloccati in coda ad un semaforo formano una lista. Ogni semaforo punta al primo elemento di questa lista attraverso il proprio campo
struct list_head s_procQ.next; e il primo PCB bloccato su un samaforo punta al successivo attraverso il proprio campo struct list_head p_next.next.
In questo caso la lista dei processi bloccati su un semaforo e` bidirezionale, non circolare senza sentinella

Ogni PCB specifica il semaforo su cui e` bloccato con un campo specifico per questo scopo, int *s_key, che punta alla stessa chiave che identifica il semforo
su cui il pcb e' bloccato


//Generic

Si e´ cercato di sfruttare il piu' possibile le macro del file listx.h per migliorare la leggibilita' del codice, e di definire funzioni per gli aspetti
piu´ ripetitivi o con un forte significato logico in vista anche di una migliore riusabilita´ del codice.
Sono possibili esempi di questo aspetto la funzione list_head* list_del_notcirc(list_head *p) la quale aiuta nella rimozione di un elemento da una
lista senza sentinella, bidirezionale non circolare;
Le funzioni inizializzapcb, inizializzasem o inizializzastate_t per l'inizializzazione delle strutture;
E le funzioni void del_tree(pcb_t* p) e void recursive(pcb_t *root, pcb_t *realroot) per la visita di tutti i processi che hanno come avo p, questa funzione
infatti si concentra sulla visita di questi elementi mentre la rimozione di questi ultimi viene affidata ad una funzione precedentemente definita,
pcb_t* outBlocked(pcb_t *p).
